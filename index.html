<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Ajedrez vs IA</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #2c2c2c;
            color: #f0f0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
        }

        h1 { margin-bottom: 10px; }

        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: #333;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        #board {
            display: grid;
            grid-template-columns: repeat(8, 60px);
            grid-template-rows: repeat(8, 60px);
            border: 5px solid #5c4033;
            user-select: none;
        }

        .square {
            width: 60px;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 45px;
            cursor: pointer;
        }

        .white-square { background-color: #eeeed2; color: black; }
        .black-square { background-color: #769656; color: black; }

        /* Piezas */
        .piece { cursor: grab; }
        .piece:active { cursor: grabbing; }
        
        /* Color de las piezas en Unicode */
        .piece.white { color: #fff; text-shadow: 0 0 2px #000; }
        .piece.black { color: #000; text-shadow: 0 0 1px #fff; }

        .selected {
            background-color: rgba(255, 255, 0, 0.5) !important;
        }

        .possible-move {
            position: relative;
        }
        .possible-move::after {
            content: '';
            position: absolute;
            width: 15px;
            height: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 50%;
        }

        #status {
            margin-top: 15px;
            font-size: 18px;
            font-weight: bold;
            color: #ddd;
        }

        #controls { margin-top: 15px; }

        button {
            padding: 10px 20px;
            background: #5c4033;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }
        button:hover { background: #7a5c4d; }

        /* Animación simple */
        @keyframes highlight {
            0% { background-color: yellow; }
            100% { background-color: transparent; }
        }
    </style>
</head>
<body>

    <div id="game-container">
        <h1>Ajedrez IA</h1>
        <div id="board"></div>
        <div id="status">Tu turno (Blancas)</div>
        <div id="controls">
            <button onclick="resetGame()">Nueva Partida</button>
        </div>
    </div>

    <script>
        // --- LÓGICA DEL JUEGO Y UI ---
        
        var board = null;
        var game = new Chess();
        var selectedSquare = null;
        
        const boardEl = document.getElementById('board');
        const statusEl = document.getElementById('status');

        // Mapeo Unicode para las piezas
        const piecesUnicode = {
            'p': '♟', 'r': '♜', 'n': '♞', 'b': '♝', 'q': '♛', 'k': '♚',
            'P': '♙', 'R': '♖', 'N': '♘', 'B': '♗', 'Q': '♕', 'K': '♔'
        };

        function drawBoard() {
            boardEl.innerHTML = '';
            const matrix = game.board(); // Obtener matriz 8x8

            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const squareDiv = document.createElement('div');
                    const isWhiteSquare = (i + j) % 2 === 0;
                    const squareId = String.fromCharCode(97 + j) + (8 - i); // e.g., "a8", "e4"
                    
                    squareDiv.classList.add('square');
                    squareDiv.classList.add(isWhiteSquare ? 'white-square' : 'black-square');
                    squareDiv.dataset.square = squareId;
                    
                    // Dibujar pieza si existe
                    const piece = matrix[i][j];
                    if (piece) {
                        const pieceSpan = document.createElement('span');
                        pieceSpan.classList.add('piece');
                        pieceSpan.classList.add(piece.color === 'w' ? 'white' : 'black');
                        // Usamos las piezas negras de unicode para ambos colores y las coloreamos con CSS
                        // para mejor visibilidad, o usamos el set completo.
                        // Para simplicidad visual aquí: usaremos el símbolo sólido para ambos y CSS color.
                        const symbolKey = piece.type; 
                        // Mapeo visual simplificado para CSS coloring
                        const symbols = { 'p':'♟', 'r':'♜', 'n':'♞', 'b':'♝', 'q':'♛', 'k':'♚' };
                        pieceSpan.innerText = symbols[symbolKey];
                        squareDiv.appendChild(pieceSpan);
                    }

                    squareDiv.addEventListener('click', onSquareClick);
                    boardEl.appendChild(squareDiv);
                }
            }
            updateStatus();
        }

        function onSquareClick(e) {
            if (game.game_over() || game.turn() === 'b') return; // Bloquear si es turno de la IA

            // Encontrar el div cuadrado (por si clickeamos la pieza)
            let target = e.target;
            if (target.classList.contains('piece')) target = target.parentElement;
            
            const squareId = target.dataset.square;
            const piece = game.get(squareId);

            // Si ya hay una seleccionada y clickeamos otra casilla -> intentar mover
            if (selectedSquare) {
                const move = game.move({
                    from: selectedSquare,
                    to: squareId,
                    promotion: 'q' // Siempre promociona a reina por simplicidad
                });

                // Limpiar selección visual
                clearHighlights();
                selectedSquare = null;

                if (move) {
                    drawBoard();
                    window.setTimeout(makeAIMove, 250); // Turno de la IA con pequeño retraso
                    return;
                }
            }

            // Si clickeamos una pieza nuestra -> Seleccionar
            if (piece && piece.color === 'w') {
                clearHighlights();
                selectedSquare = squareId;
                target.classList.add('selected');
                
                // Mostrar movimientos posibles
                const moves = game.moves({ square: squareId, verbose: true });
                moves.forEach(move => {
                    const el = document.querySelector(`[data-square="${move.to}"]`);
                    el.classList.add('possible-move');
                });
            }
        }

        function clearHighlights() {
            document.querySelectorAll('.square').forEach(el => {
                el.classList.remove('selected');
                el.classList.remove('possible-move');
            });
        }

        function updateStatus() {
            let status = '';
            let moveColor = game.turn() === 'w' ? 'Blancas' : 'Negras';

            if (game.in_checkmate()) {
                status = 'Juego terminado, ' + moveColor + ' están en jaque mate.';
            } else if (game.in_draw()) {
                status = 'Juego terminado, tablas.';
            } else {
                status = 'Turno de: ' + moveColor;
                if (game.in_check()) {
                    status += ', ' + moveColor + ' están en jaque';
                }
            }
            statusEl.innerText = status;
        }

        function resetGame() {
            game.reset();
            selectedSquare = null;
            drawBoard();
        }

        // --- INTELIGENCIA ARTIFICIAL (IA) ---
        
        // Tablas de evaluación (Piece-Square Tables)
        // Valores positivos indican que es bueno para las Negras (porque la IA es negra)
        // Nota: Estas tablas están desde la perspectiva de las blancas, así que las invertiremos.
        
        const pst_w = {
            p: [
                [0,  0,  0,  0,  0,  0,  0,  0],
                [50, 50, 50, 50, 50, 50, 50, 50],
                [10, 10, 20, 30, 30, 20, 10, 10],
                [5,  5, 10, 25, 25, 10,  5,  5],
                [0,  0,  0, 20, 20,  0,  0,  0],
                [5, -5,-10,  0,  0,-10, -5,  5],
                [5, 10, 10,-20,-20, 10, 10, 5],
                [0,  0,  0,  0,  0,  0,  0,  0]
            ],
            n: [
                [-50,-40,-30,-30,-30,-30,-40,-50],
                [-40,-20,  0,  0,  0,  0,-20,-40],
                [-30,  0, 10, 15, 15, 10,  0,-30],
                [-30,  5, 15, 20, 20, 15,  5,-30],
                [-30,  0, 15, 20, 20, 15,  0,-30],
                [-30,  5, 10, 15, 15, 10,  5,-30],
                [-40,-20,  0,  5,  5,  0,-20,-40],
                [-50,-40,-30,-30,-30,-30,-40,-50]
            ],
            b: [
                [-20,-10,-10,-10,-10,-10,-10,-20],
                [-10,  0,  0,  0,  0,  0,  0,-10],
                [-10,  0,  5, 10, 10,  5,  0,-10],
                [-10,  5,  5, 10, 10,  5,  5,-10],
                [-10,  0, 10, 10, 10, 10,  0,-10],
                [-10, 10, 10, 10, 10, 10, 10,-10],
                [-10,  5,  0,  0,  0,  0,  5,-10],
                [-20,-10,-10,-10,-10,-10,-10,-20]
            ],
            r: [
                [0,  0,  0,  0,  0,  0,  0,  0],
                [5, 10, 10, 10, 10, 10, 10,  5],
                [-5,  0,  0,  0,  0,  0,  0, -5],
                [-5,  0,  0,  0,  0,  0,  0, -5],
                [-5,  0,  0,  0,  0,  0,  0, -5],
                [-5,  0,  0,  0,  0,  0,  0, -5],
                [-5,  0,  0,  0,  0,  0,  0, -5],
                [0,  0,  0,  5,  5,  0,  0,  0]
            ],
            q: [
                [-20,-10,-10, -5, -5,-10,-10,-20],
                [-10,  0,  0,  0,  0,  0,  0,-10],
                [-10,  0,  5,  5,  5,  5,  0,-10],
                [-5,  0,  5,  5,  5,  5,  0, -5],
                [0,  0,  5,  5,  5,  5,  0, -5],
                [-10,  5,  5,  5,  5,  5,  0,-10],
                [-10,  0,  5,  0,  0,  0,  0,-10],
                [-20,-10,-10, -5, -5,-10,-10,-20]
            ],
            k: [
                [-30,-40,-40,-50,-50,-40,-40,-30],
                [-30,-40,-40,-50,-50,-40,-40,-30],
                [-30,-40,-40,-50,-50,-40,-40,-30],
                [-30,-40,-40,-50,-50,-40,-40,-30],
                [-20,-30,-30,-40,-40,-30,-30,-20],
                [-10,-20,-20,-20,-20,-20,-20,-10],
                [20, 20,  0,  0,  0,  0, 20, 20],
                [20, 30, 10,  0,  0, 10, 30, 20]
            ]
        };

        // Invertir tablas para las negras
        const pst_b = {};
        for (let piece in pst_w) {
            pst_b[piece] = pst_w[piece].slice().reverse();
        }

        const pieceValues = { p: 100, n: 320, b: 330, r: 500, q: 900, k: 20000 };

        function evaluateBoard(game) {
            let totalEvaluation = 0;
            const board = game.board();

            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const piece = board[i][j];
                    if (piece) {
                        const value = pieceValues[piece.type];
                        const pst = (piece.color === 'w' ? pst_w[piece.type][i][j] : pst_b[piece.type][i][j]);
                        
                        // Si es pieza blanca, restamos (porque la IA quiere minimizar el score a favor de negras)
                        // Espera, Minimax maximiza para el jugador actual.
                        // Haremos: Score positivo = Bueno para la IA (Negras). Score negativo = Bueno para blancas.
                        
                        if (piece.color === 'b') {
                            totalEvaluation += (value + pst);
                        } else {
                            totalEvaluation -= (value + pst);
                        }
                    }
                }
            }
            return totalEvaluation;
        }

        // Algoritmo Minimax con Poda Alpha-Beta
        function minimax(game, depth, alpha, beta, isMaximizingPlayer) {
            if (depth === 0 || game.game_over()) {
                return evaluateBoard(game);
            }

            const newGameMoves = game.moves();

            if (isMaximizingPlayer) {
                let maxEval = -Infinity;
                for (let i = 0; i < newGameMoves.length; i++) {
                    game.move(newGameMoves[i]);
                    const ev = minimax(game, depth - 1, alpha, beta, false);
                    game.undo();
                    maxEval = Math.max(maxEval, ev);
                    alpha = Math.max(alpha, ev);
                    if (beta <= alpha) break;
                }
                return maxEval;
            } else {
                let minEval = Infinity;
                for (let i = 0; i < newGameMoves.length; i++) {
                    game.move(newGameMoves[i]);
                    const ev = minimax(game, depth - 1, alpha, beta, true);
                    game.undo();
                    minEval = Math.min(minEval, ev);
                    beta = Math.min(beta, ev);
                    if (beta <= alpha) break;
                }
                return minEval;
            }
        }

        function makeAIMove() {
            statusEl.innerText = "Pensando...";
            
            // Usamos setTimeout para que el navegador renderice el texto "Pensando..."
            setTimeout(() => {
                const moves = game.moves();
                if (moves.length === 0) return;

                let bestMove = null;
                let bestValue = -Infinity; // La IA quiere maximizar su puntaje (definido positivo para negras arriba)

                // Profundidad 3 es un buen balance para JS en navegador
                const depth = 3; 

                for (let i = 0; i < moves.length; i++) {
                    game.move(moves[i]);
                    // Llamamos a minimax. La IA es Maximizadora (Negras), el siguiente turno es Blancas (Minimizadoras)
                    const boardValue = minimax(game, depth - 1, -Infinity, Infinity, false);
                    game.undo();

                    if (boardValue > bestValue) {
                        bestValue = boardValue;
                        bestMove = moves[i];
                    }
                }

                game.move(bestMove);
                drawBoard();
            }, 10);
        }

        // Iniciar
        drawBoard();

    </script>
</body>
</html>
